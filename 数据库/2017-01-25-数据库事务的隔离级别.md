---
title: 数据库事务的隔离级别
author: essviv
date: 2017-01-25 05:34:25+0800
---

# 数据库事务的隔离级别

## 隔离级别
1. 数据库事务的隔离级别分为四个： **未提交读， 提交读，重复读以及序列化**，不同隔离级别能解决的问题以及不能解决的问题如下：
![transaction-level](https://github.com/Essviv/images/blob/master/transaction.jpg?raw=true)

2. **重复读**会对读的范围加锁，也就是在第一次读操作开始的时候，事务会对它所读的范围进行加锁，其它的事务就不能对这个范围内的记录进行修改和删除操作，以此来保证它的重复读；但它不能保证选择范围外的记录不被修改或增加，因此无法避免幻读的情况(select)

3. **幻读**更多的是针对增加或修改范围外的记录的情况而言的

4. **提交读**的读锁是在读完之后就被立即释放，而写锁是在事务提交时释放，当事务A的读锁释放后，这部分数据就可能被其它事务修改，因此 它会导致不可重复读的问题； 重复读获取的也是读锁，但读锁直到事务结束才会被释放， 因此它能够解决重复读的问题，但是因为它没有范围锁，所以无法避免幻读的情况； 

## 隔离级别和锁的联系

### 封锁（Locking）
 
封锁是实现并发控制的一个非常重要的技术。所谓封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该 数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。 基本的封锁类型有两种：排它锁（Exclusive locks 简记为X锁）和共享锁（Share locks 简记为S锁）。 

排它锁又称为写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其它事务在T释放A上的锁之前不能再读取和修改A。 

共享锁又称为读锁。若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其它事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 

### 封锁协议
 
在 运用X锁和S锁这两种基本封锁，对数据对象加锁时，还需要约定一些规则，例如应何时申请X锁或S锁、持锁时间、何时释放等。我们称这些规则为封锁协议 （Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。下面介绍三级封锁协议。三级封锁协议分别在不同程度上解决了丢失的修改、不 可重复读和读"脏"数据等不一致性问题，为并发操作的正确调度提供一定的保证。下面只给出三级封锁协议的定义，不再做过多探讨。
 
**1级封锁协议**：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。 1级封锁协议可防止丢失修改，并保证事务T是可恢复的。在1级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读"脏"数据。

**2级封锁协议**：1级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。2级封锁协议除防止了丢失修改，还可进一步防止读"脏"数据。 一旦释放了S锁之后，其它的事务就可以对这部分数据进行修改，因此它无法避免重复读的问题。

**3级封锁协议**：1级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。3级封锁协议除防止了丢失修改和不读'脏'数据外，还进一步防止了不可重复读。  


## 参考文献

1. [文献1](http://blog.csdn.net/fg2006/article/details/6937413)
 
2. [文献2](http://blog.sina.com.cn/s/blog_616b428f010163bo.html)
  
3. [隔离级别和锁的联系](http://www.cnblogs.com/tqsummer/archive/2010/07/11/1775209.html)
 
4. [数据库并发的五个问题及四级封锁协议](http://blog.csdn.net/zhangzeyuaaa/article/details/46400419)