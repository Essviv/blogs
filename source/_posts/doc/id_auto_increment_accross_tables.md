---
title: id_auto_increment_accross_tables
author: essviv
date: 2016-01-25 10:20:54+0800
---

#分表情况下的用户ID自增策略

总得来讲，在数据库中记录当前已经生成的用户ID数，缓存启动时，读取这个值并将它增加一定的数量（100，1000),然后在缓存中预先生成相应数量的ID值，当应用层请求生成用户ID时，直接从缓存中取出预先生成的值，若缓存里的值被取完，继续更新数据库，生成新的ID值

##几点考虑
1. 缓存系统崩溃：此时只需要重新启动即可，缓存会根据数据库中记录的值生成新一批ID，不会出现重复的情况，不过这种情况下，整个系统会丢失缓存崩溃时遗留在缓存系统中的那批ID

2. 效率考虑：由于缓存系统每次总是从数据库里更新并生成一定数量的ID，当应用层请求生成ID时，是从缓存里直接读取预先生成好的ID，比起每次都读取再更新数据库，效率要高出很多

3. 每次生成ID的数量：如果每次生成的数量很多，那么后续取ID时效率会很高，但相应地，如果缓存系统崩溃，丢失大量未使用ID的概率也更大，因此更适合于短时间内生成大量ID的场景;相反，如果每次生成的数量很少，会导致请求数据库的次数增加（极端情况，将每次生成的ID数量设成1，那么就和直接操作数据库没有区别），影响效率，但可以有效地避免丢失ID的情况。

4. 注意： 更新数据库的时候，可以考虑采用乐观锁，防止多线程情况下更新数据库导致相同的ID值出现

		Jedis jedis = newJedis();
        String value = jedis.spop(KEY);
        while (StringUtils.isBlank(value)) {
            updateCacheAndDB(jedis);
            value = jedis.spop(KEY);
        }

        try {
            return NumberUtils.toLong(value);
        } finally {
            if (jedis != null) {
                jedis.close();
            }
        }